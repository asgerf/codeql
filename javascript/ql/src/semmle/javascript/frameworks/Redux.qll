/**
 * Provides classes and predicates for reasoning about data flow through the redux package.
 */

import javascript

// The core Redux model contributes two kinds of steps:
//   1. From dispatch argument to reducer parameter ("dispatch step")
//   2. From reducer return-value to state access ("reducer step")
//
// A third kind of step is also needed to adapter libraries like `react-redux`, for example:
//   3. From mapStateToProps return-value to props access in react component
//
// The third kind of step is technically independent of the core Redux library, but
// this file includes modeling of such adapter libraries as well.
//
// The first step, from dispatch to reducer, has to deal with type tags, so it can't always
// map to a function parameter.

// TODO: typescript-fsa family of packages
// TODO: handle immer-style `state.foo = foo` assignments in reducer; add steps back to state access paths

module Redux {
  /**
   * Gets a node interprocedurally reachable from `source`, where `source` must be known
   * to have a corresponding use-node in the API graph.
   *
   * We use this to maintain a consistent interface based on data-flow nodes, while being
   * able to reuse the type-tracking done by API graphs in cases where the node is known to
   * be part of the API graph.
   */
  pragma[inline]
  private DataFlow::SourceNode getAnApiReference(DataFlow::SourceNode source) {
    exists(API::Node apiNode |
      apiNode.getAnImmediateUse() = source and
      result = apiNode.getAUse()
    )
  }

  /**
   * Creation of a redux store, usually via a call to `createStore`.
   */
  class StoreCreation extends DataFlow::SourceNode {
    StoreCreation::Range range;

    StoreCreation() { this = range }

    /** Gets a reference to the store. */
    DataFlow::SourceNode ref() { result = getAnApiReference(this) }

    /** Gets the data flow node holding the root reducer for this store. */
    DataFlow::Node getReducerArg() { result = range.getReducerArg() }

    /** Gets a data flow node referring to the root reducer. */
    DataFlow::SourceNode getAReducerSource() { result = getReducerArg().(ReducerArg).getASource() }
  }

  /** Companion module to the `StoreCreation` class. */
  module StoreCreation {
    /**
     * Creation of a redux store. Additional `StoreCreation` instances can be generated by subclassing this class.
     */
    abstract class Range extends DataFlow::SourceNode {
      abstract DataFlow::Node getReducerArg();
    }

    private class CreateStore extends DataFlow::CallNode, Range {
      CreateStore() { this = API::moduleImport(["redux", "@reduxjs/toolkit"]).getMember("createStore").getACall() }

      override DataFlow::Node getReducerArg() { result = getArgument(0) }
    }

    private class ToolkitStore extends API::CallNode, Range {
      ToolkitStore() {
        this = API::moduleImport("@reduxjs/toolkit").getMember("configureStore").getACall()
      }

      override DataFlow::Node getReducerArg() {
        result = getParameter(0).getMember("reducer").getARhs()
      }
    }
  }

  private StoreCreation getAStoreImportedFrom(TopLevel tl) {
    result.getTopLevel() = tl
    or
    result = getAStoreImportedFrom(tl.(Module).getAnImportedModule())
  }

  private StoreCreation getAStoreRelevantFor(TopLevel tl) {
    result = getAStoreImportedFrom(tl)
    or
    exists(Module m |
      m.getAnImportedModule() = tl and
      result = getAStoreRelevantFor(m)
    )
  }

  /** An API node referring to the root state. */
  abstract private class RootStateNode extends API::Node { }

  /** Gets an API node corresponding to an access of `prop` on the root state of `store`. */
  pragma[noinline]
  private API::Node rootStatePropRaw(string prop, StoreCreation store) {
    result = any(RootStateNode n).getMember(prop) and
    store = getAStoreRelevantFor([result.getAnImmediateUse().getTopLevel(), result.getARhs().getTopLevel()])
  }

  /**
   * Gets an API node corresponding to an access of `prop` on the root state of some store
   * that is relevant at `useSite`.
   */
  pragma[inline]
  private API::Node rootStatePropFrom(string prop, TopLevel useSite) {
    result = rootStatePropRaw(prop, getAStoreRelevantFor(useSite))
  }

  /** A data flow node that is used as a reducer. */
  private class ReducerArg extends DataFlow::Node {
    ReducerArg() {
      this = any(StoreCreation c).getReducerArg()
      or
      this = any(DelegatingReducer r).getStateHandlerArg(_)
      or
      this = any(DelegatingReducer r).getActionHandlerArg(_)
    }

    /** Gets a data flow node that flows to this reducer argument. */
    DataFlow::SourceNode getASource(DataFlow::TypeBackTracker t) {
      t.start() and
      result = getALocalSource()
      or
      exists(DataFlow::Node mid | result.flowsTo(mid) |
        // Step through forwarding functions
        DataFlow::functionForwardingStep(mid, getASource(t.continue()))
        or
        // Step through library functions like `redux-persist`
        mid = getASource(t.continue()).(DelegatingReducer).getAPlainHandlerArg()
        or
        // Step through function composition (usually composed with various state "enhancer" functions)
        exists(FunctionCompositionCall compose, DataFlow::CallNode call |
          call = compose.getACall() and
          getASource(t.continue()) = call and
          mid = [compose.getAnOperandNode(), call.getAnArgument()]
        )
      )
      or
      exists(DataFlow::TypeBackTracker t2 | result = getASource(t2).backtrack(t2, t))
    }

    /** Gets a data flow node that flows to this reducer argument. */
    DataFlow::SourceNode getASource() { result = getASource(DataFlow::TypeBackTracker::end()) }

    /**
     * Holds if the actions discpatched to this reducer have the given type, that is,
     * it is created by an action creator that flows to `actionType`, or has `action.type` set to
     * the string value of `actionType`.
     */
    predicate isActionTypeHandler(DataFlow::Node actionType) {
      exists(DelegatingReducer r |
        this = r.getActionHandlerArg(actionType)
        or
        this = r.getStateHandlerArg(_) and
        r.getUseSite().isActionTypeHandler(actionType)
      )
    }

    /**
     * Holds if the actions dispatched to this reducer have the given `action.type` value.
     */
    predicate isTypeTagHandler(string actionType) {
      exists(DataFlow::Node node |
        isActionTypeHandler(node) and
        actionType = getATypeTagFromNode(node)
      )
    }

    /**
     * Holds if this reducer operates on the root state, as opposed to some access path within the state.
     */
    predicate isRootStateHandler() {
      this = any(StoreCreation c).getReducerArg()
      or
      exists(DelegatingReducer r |
        this = r.getActionHandlerArg(_) and
        r.getUseSite().isRootStateHandler()
      )
    }
  }

  /**
   * Creation of a reducer function that delegates to one or more other reducer functions.
   *
   * Delegating reducers can delegate specific parts of the state object (`getStateHandlerArg`),
   * actions of a specific type (`getActionHandlerArg`), or everything (`getAPlainHandlerArg`).
   */
  abstract class DelegatingReducer extends DataFlow::SourceNode {
    /**
     * Gets a data flow node holding a reducer to which handling of `state.prop` is delegated.
     *
     * For example, gets the `fn` in `combineReducers({foo: fn})` with `prop` bound to `foo`.
     *
     * The delegating reducer should behave as a function of this form:
     * ```js
     * function outer(state, action) {
     *   return {
     *     prop: inner(state.prop, action),
     *     ...
     *   }
     * }
     * ```
     */
    DataFlow::Node getStateHandlerArg(string prop) { none() }

    /**
     * Gets a data flow node holding a reducer to which actions of the given type are delegated.
     *
     * For example, gets the `fn` in `handleAction(a, fn)` with `actionType` bound to `a`.
     *
     * The `actionType` node may refer an action creator or a string value corresponding to `action.type`.
     */
    DataFlow::Node getActionHandlerArg(DataFlow::Node actionType) { none() }

    /**
     * Gets a data flow node holding a reducer to which every request is forwarded (for the
     * purpose of this model).
     *
     * For example, gets the `fn` in `persistReducer(config, fn)`.
     */
    DataFlow::Node getAPlainHandlerArg() { none() }

    /** Gets the use site of this reducer. */
    final ReducerArg getUseSite() { result.getASource() = this }
  }

  private API::Node combineReducers() {
    result = API::moduleImport(["redux", "redux-immutable", "@reduxjs/toolkit"]).getMember("combineReducers")
  }

  /**
   * A call to `combineReducers`, which delegates properties of `state` to individual sub-reducers.
   */
  private class CombineReducers extends API::CallNode, DelegatingReducer {
    CombineReducers() {
      this = combineReducers().getACall()
    }

    override DataFlow::Node getStateHandlerArg(string prop) {
      result = getParameter(0).getMember(prop).getARhs()
    }
  }

  /**
   * An object literal flowing into a nested property in a `combineReducers` object, such as the `{ bar }` object in:
   * ```js
   * combineReducers({ foo: { bar } })
   * ```
   *
   * Although the object itself is clearly not a function, we use the object to model the corresponding reducer function created by `combineReducers`.
   */
  private class NestedCombineReducers extends DelegatingReducer, DataFlow::ObjectLiteralNode {
    NestedCombineReducers() {
      this = combineReducers().getParameter(0).getAMember+().getAValueReachingRhs()
    }

    override DataFlow::Node getStateHandlerArg(string prop) {
      result = getAPropertyWrite(prop).getRhs()
    }
  }

  /** Gets the `redux-actions` library or one similar enough that we can model them as identical. */
  private API::Node reduxActionsLike() {
    result = API::moduleImport(["redux-actions", "redux-ts-utils"])
  }

  /**
   * Gets the type tag of an action creator reaching `node`, or the type tag from one of the action
   * types passed to a `combineActions` call reaching `node`.
   */
  private string getAnActionTypeTag(DataFlow::SourceNode node) {
    exists(ActionCreator action |
      node = action.ref() and
      result = action.getTypeTag()
    )
  }

  /** Gets the type tag of an action reaching `node`, or the string value of `node`. */
  pragma[inline] // Inlined to avoid duplicating `mayHaveStringValue`
  private string getATypeTagFromNode(DataFlow::Node node) {
    node.mayHaveStringValue(result)
    or
    result = getAnActionTypeTag(node.getALocalSource())
  }

  private class HandleActions extends API::CallNode, DelegatingReducer {
    HandleActions() {
      this = reduxActionsLike().getMember("handleActions").getACall()
    }

    override DataFlow::Node getActionHandlerArg(DataFlow::Node actionType) {
      exists(DataFlow::PropWrite write |
        result = getParameter(0).getAMember().getARhs() and
        write.getRhs() = result and
        actionType = write.getPropertyNameExpr().flow()
      )
    }
  }

  private class HandleAction extends API::CallNode, DelegatingReducer {
    HandleAction() {
      this = reduxActionsLike().getMember("handleAction").getACall()
    }

    override DataFlow::Node getActionHandlerArg(DataFlow::Node actionType) {
      actionType = getArgument(0) and
      result = getArgument(1)
    }
  }

  private class PersistReducer extends DataFlow::CallNode, DelegatingReducer {
    PersistReducer() {
      this = API::moduleImport("redux-persist").getMember("persistReducer").getACall()
    }

    override DataFlow::Node getAPlainHandlerArg() {
      result = getArgument(1)
    }
  }

  private class ImmerProduce extends DataFlow::CallNode, DelegatingReducer {
    ImmerProduce() {
      this = API::moduleImport("immer").getACall()
      or
      this = API::moduleImport("immer").getMember("produce").getACall()
    }

    override DataFlow::Node getAPlainHandlerArg() {
      result = getArgument(0)
    }
  }

  /**
   * Model `reduce-reducers` as a reducer that dispatches to an arbitrary subreducer.
   *
   * Concretely, it chains together all of the reducers, but in practice it is only used
   * when the reducers handle a disjoint set of action types.
   */
  private class ReduceReducers extends DataFlow::CallNode, DelegatingReducer {
    ReduceReducers() {
      this = API::moduleImport("reduce-reducers").getACall() or
      this = reduxActionsLike().getMember("reduceReducers").getACall()
    }

    override DataFlow::Node getAPlainHandlerArg() {
      result = getAnArgument()
      or
      result = getArgument(0).getALocalSource().(DataFlow::ArrayCreationNode).getAnElement()
    }
  }

  private class CreateReducer extends API::CallNode, DelegatingReducer {
    CreateReducer() {
      this = API::moduleImport("@reduxjs/toolkit").getMember("createReducer").getACall()
    }

    private API::Node getABuilderRef() {
      result = getParameter(1).getParameter(0)
      or
      result = getABuilderRef().getAMember().getReturn()
    }

    override DataFlow::Node getActionHandlerArg(DataFlow::Node actionType) {
      exists(API::CallNode addCase |
        addCase = getABuilderRef().getMember("addCase").getACall() and
        actionType = addCase.getArgument(0) and
        result = addCase.getArgument(1)
      )
    }
  }

  private class CreateSliceReducer extends DelegatingReducer {
    API::CallNode call;

    CreateSliceReducer() {
      call = API::moduleImport("@reduxjs/toolkit").getMember("createSlice").getACall() and
      this = call.getReturn().getMember("reducer").getAnImmediateUse()
    }

    private API::Node getABuilderRef() {
      result = call.getParameter(0).getMember("extraReducers").getParameter(0)
      or
      result = getABuilderRef().getAMember().getReturn()
    }

    override DataFlow::Node getActionHandlerArg(DataFlow::Node actionType) {
      exists(string name |
        result = call.getParameter(0).getMember("reducers").getMember(name).getARhs() and
        actionType = call.getReturn().getMember("actions").getMember(name).getAnImmediateUse()
      )
      or
      // Properties of 'extraReducers':
      //   { extraReducers: { [action]: reducer }}
      exists(DataFlow::PropWrite write |
        result = call.getParameter(0).getMember("extraReducers").getAMember().getARhs() and
        write.getRhs() = result and
        actionType = write.getPropertyNameExpr().flow()
      )
      or
      // Builder callback to 'extraReducers':
      //   extraReducers: builder => builder.addCase(action, reducer)
      exists(API::CallNode addCase |
        addCase = getABuilderRef().getMember("addCase").getACall() and
        actionType = addCase.getArgument(0) and
        result = addCase.getArgument(1)
      )
    }
  }

  private class CreateSliceAction extends ActionCreator::Range {
    API::CallNode call;
    string actionName;

    CreateSliceAction() {
      call = API::moduleImport("@reduxjs/toolkit").getMember("createSlice").getACall() and
      this = call.getReturn().getMember("actions").getMember(actionName).getAnImmediateUse()
    }

    override string getTypeTag() {
      exists(string prefix |
        call.getParameter(0).getMember("name").getARhs().mayHaveStringValue(prefix) and
        result = prefix + "/" + actionName
      )
    }
  }

  private class CreateAsyncThunk extends ActionCreator::Range, API::CallNode {
    CreateAsyncThunk() {
      this = API::moduleImport("@reduxjs/toolkit").getMember("createAsyncThunk").getACall()
    }

    override DataFlow::FunctionNode getMiddlewareFunction(boolean async) {
      async = true and
      result = getParameter(1).getAValueReachingRhs()
    }

    override string getTypeTag() {
      getArgument(0).mayHaveStringValue(result)
    }
  }

  /**
   * A source of the `dispatch` function, used as starting point for `getADispatchFunctionReference`.
   */
  abstract private class DispatchFunctionSource extends DataFlow::SourceNode { }

  /**
   * A value that is dispatched, that is, flows to the first argument of `dispatch`
   * (but where the call to `dispatch` is not necessarily explicit in the code).
   *
   * Used as starting point for `getADispatchedValueSource`.
   */
  abstract private class DispatchedValueSink extends DataFlow::Node { }

  private class StoreDispatchSource extends DispatchFunctionSource {
    StoreDispatchSource() { this = any(StoreCreation c).ref().getAPropertyRead("dispatch") }
  }

  /** Gets a data flow node referring to the `dispatch` function. */
  private DataFlow::SourceNode getADispatchFunctionReference(DataFlow::TypeTracker t) {
    t.start() and
    result instanceof DispatchFunctionSource
    or
    // When using the redux-thunk middleware, dispatching a function value results in that
    // function being invoked with (dispatch, getState).
    // We simply assume redux-thunk middleware is always installed.
    t.start() and
    result = getADispatchedValueSource().(DataFlow::FunctionNode).getParameter(0)
    or
    exists(DataFlow::TypeTracker t2 | result = getADispatchFunctionReference(t2).track(t2, t))
  }

  /** Gets a data flow node referring to the `dispatch` function. */
  DataFlow::SourceNode getADispatchFunctionReference() {
    result = getADispatchFunctionReference(DataFlow::TypeTracker::end())
  }

  /** Gets a data flow node that is dispatched as an action. */
  private DataFlow::SourceNode getADispatchedValueSource(DataFlow::TypeBackTracker t) {
    t.start() and
    result = any(DispatchedValueSink d).getALocalSource()
    or
    t.start() and
    result = getADispatchFunctionReference().getACall().getArgument(0).getALocalSource()
    or
    exists(DataFlow::TypeBackTracker t2 | result = getADispatchedValueSource(t2).backtrack(t2, t))
  }

  /**
   * Gets a data flow node that is dispatched as an action, that is, it flows to the first argument of `dispatch`.
   */
  DataFlow::SourceNode getADispatchedValueSource() {
    result = getADispatchedValueSource(DataFlow::TypeBackTracker::end())
  }

  /** Gets the `action` parameter of a reducer that isn't behind an implied type guard. */
  DataFlow::SourceNode getAnUntypedActionInReducer() {
    exists(ReducerArg reducer |
      not reducer.isTypeTagHandler(_) and
      result = reducer.getASource().(DataFlow::FunctionNode).getParameter(1)
    )
  }

  /** A call to `bindActionCreators` */
  private class BindActionCreatorsCall extends API::CallNode {
    BindActionCreatorsCall() {
      this = API::moduleImport(["redux", "@reduxjs/toolkit"]).getMember("bindActionCreators").getACall()
    }
  }

  /** The return value of a function flowing into `bindActionCreators` is dispatched */
  private class BindActionDispatchSink extends DispatchedValueSink {
    BindActionDispatchSink() {
      this = any(BindActionCreatorsCall c).getParameter(0).getAMember().getReturn().getARhs()
    }
  }

  /**
   * A function for creating and dispatching action objects of shape `{type, payload}`.
   *
   * An action creator is a function, which, for some string `T` behaves as the function `x => {type: T, payload: x}`.
   */
  class ActionCreator extends DataFlow::SourceNode {
    ActionCreator::Range range;
  
    ActionCreator() { this = range }

    /** Gets the `type` property of actions created by this action creator, if it is known. */
    string getTypeTag() { result = range.getTypeTag() }

    /**
     * Gets the middleware function that transforms arguments passed to this function into the
     * action payload.
     *
     * Not every action creator has a middleware function; in such cases the first argument is
     * treated as the action payload.
     *
     * If `async` is true, the middlware function returns a promise whose value eventually becomes
     * the action payload. Otherwise, the return valeu is the payload itself.
     */
    DataFlow::FunctionNode getMiddlewareFunction(boolean async) { result = range.getMiddlewareFunction(async) }

    /** Gets a data flow node referring to this action creator. */
    private DataFlow::SourceNode ref(DataFlow::TypeTracker t) {
      t.start() and
      result = this 
      or
      // x -> bindActionCreators({ x, ... })
      exists(BindActionCreatorsCall bind, string prop |
        ref(t.continue()).flowsTo(bind.getParameter(0).getMember(prop).getARhs()) and
        result = bind.getReturn().getMember(prop).getAnImmediateUse()
      )
      or
      // x -> combineActions(x, ...)
      exists(API::CallNode combiner |
        combiner = reduxActionsLike().getMember("combineActions").getACall() and
        ref(t.continue()).flowsTo(combiner.getAnArgument()) and
        result = combiner
      )
      or
      // x -> x.fulfilled, for async action creators
      result = ref(t.continue()).getAPropertyRead("fulfilled")
      or
      // follow flow through mapDispatchToProps
      ReactRedux::dispatchToPropsStep(ref(t.continue()).getALocalUse(), result)
      or
      exists(DataFlow::TypeTracker t2 |
        result = ref(t2).track(t2, t)
      )
    }
    
    /** Gets a data flow node referring to this action creator. */
    DataFlow::SourceNode ref() {
      result = ref(DataFlow::TypeTracker::end())
    }

    /**
     * Holds if `successBlock` is executed when a check has determined that `action` originated from this action creator.
     */
    private ReachableBasicBlock getASuccessfulTypeCheckBlock(DataFlow::SourceNode action) {
      result = getASuccessfulTypeCheckBlock(action, getTypeTag())
      or
      // some action creators implement a .match method for this purpose
      exists(ConditionGuardNode guard, DataFlow::CallNode call |
        call = ref().getAMethodCall("match") and
        guard.getTest() = call.asExpr() and
        action.flowsTo(call.getArgument(0)) and
        guard.getOutcome() = true and
        result = guard.getBasicBlock()
      )
    }

    /** Gets a data flow node referring a payload of this action (usually in the reducer function). */
    DataFlow::SourceNode getAPayloadReference() {
      // `if (action.type === TYPE) { ... action.payload ... }`
      exists(DataFlow::SourceNode actionSrc |
        result = actionSrc.getAPropertyRead("payload") and
        getASuccessfulTypeCheckBlock(actionSrc).dominates(result.getBasicBlock())
      )
      or
      // handleAction(TYPE, (state, action) => { ... action.payload ... })
      exists(ReducerArg reducer |
        (
          reducer.isTypeTagHandler(getTypeTag())
          or
          reducer.isActionTypeHandler(ref().getALocalUse())
        ) and
        result = reducer.getASource().(DataFlow::FunctionNode).getParameter(1).getAPropertyRead("payload")
      )
    }
  }

  /** Companion module to the `ActionCreator` class. */
  module ActionCreator {
    /** A function for creating and dispatching action objects of shape `{type, payload}`. */
    abstract class Range extends DataFlow::SourceNode {
      /** Gets the `type` property of actions created by this action creator */
      abstract string getTypeTag();

      /** Gets the function transforming arguments into the action payload. */
      DataFlow::FunctionNode getMiddlewareFunction(boolean async) { none() }
    }

    /** An action creator made using `createAction` */
    private class SingleAction extends Range, API::CallNode {
      SingleAction() {
        this =
          API::moduleImport(["@reduxjs/toolkit", "redux-actions", "redux-ts-utils"])
              .getMember("createAction")
              .getACall()
      }

      override string getTypeTag() {
        getArgument(0).mayHaveStringValue(result)
      }
    }

    /** One of the dispatchers created by a call to `createActions` from `redux-actions`. */
    class MultiAction extends Range {
      API::CallNode createActions;
      string name;

      MultiAction() {
        createActions = API::moduleImport("redux-actions").getMember("createActions").getACall() and
        this = createActions.getReturn().getMember(name).getAnImmediateUse()
      }

      override DataFlow::FunctionNode getMiddlewareFunction(boolean async) {
        result.flowsTo(createActions.getParameter(0).getMember(getTypeTag()).getARhs()) and
        async = false
      }

      override string getTypeTag() {
        result = name.regexpReplaceAll("([a-z])([A-Z])", "$1_$2").toUpperCase()
      }
    }
  }

  /**
   * Holds if `pred -> succ` is step from an action creation to its use in a reducer function.
   */
  predicate actionToReducerStep(DataFlow::Node pred, DataFlow::SourceNode succ) {
    // Actions created by an action creator library
    exists(ActionCreator action |
      exists(DataFlow::CallNode call | call = action.ref().getACall() |
        exists(int i |
          pred = call.getArgument(i) and
          succ = action.getMiddlewareFunction(_).getParameter(i)
        )
        or
        not exists(action.getMiddlewareFunction(_)) and
        pred = call.getArgument(0) and
        succ = action.getAPayloadReference()
      )
      or
      pred = action.getMiddlewareFunction(true).getReturnNode() and
      succ = action.getAPayloadReference()
    )
    or
    // Manually created and dispatched actions
    exists(string actionType, string prop, DataFlow::SourceNode actionSrc |
      pred = getAManuallyDispatchedValue(actionType).getAPropertyWrite(prop).getRhs() and
      succ = actionSrc.getAPropertyRead(prop)
    |
      getASuccessfulTypeCheckBlock(actionSrc, actionType).dominates(succ.getBasicBlock())
      or
      exists(ReducerArg reducer |
        reducer.isTypeTagHandler(actionType) and
        actionSrc = reducer.getASource().(DataFlow::FunctionNode).getParameter(1)
      )
    )
  }

  /** Holds if `pred -> succ` is a step from the promise of an action payload to its use in a reducer function. */
  predicate actionToReducerPromiseStep(DataFlow::Node pred, DataFlow::SourceNode succ) {
    exists(ActionCreator action |
      pred = action.getMiddlewareFunction(true).getReturnNode() and
      succ = action.getAPayloadReference()
    )
  }

  private class ActionToReducerStep extends DataFlow::AdditionalFlowStep {
    ActionToReducerStep() {
      actionToReducerStep(_, this)
      or
      actionToReducerPromiseStep(_, this)
    }

    override predicate step(DataFlow::Node pred, DataFlow::Node succ) {
      actionToReducerStep(pred, succ) and succ = this
    }

    override predicate loadStep(DataFlow::Node pred, DataFlow::Node succ, string prop) {
      actionToReducerPromiseStep(pred, succ) and succ = this and prop = Promises::valueProp()
    }
  }

  /** Gets the API node for a non-root state access affected by `reducer`'s return value. */
  private API::Node getAnAffectedStateAccess(ReducerArg reducer) {
    exists(DelegatingReducer r |
      exists(string prop | reducer = r.getStateHandlerArg(prop) |
        result = getAnAffectedStateAccess(r.getUseSite()).getMember(prop)
        or
        r.getUseSite().isRootStateHandler() and
        result = rootStatePropFrom(prop, reducer.getTopLevel())
      )
      or
      reducer = r.getActionHandlerArg(_) and
      result = getAnAffectedStateAccess(r.getUseSite())
      or
      exists(DataFlow::Node succ |
        ReactRedux::stateToPropsStep(getAnAffectedStateAccess(reducer).getAUse(), succ) and
        result.getAnImmediateUse() = succ
      )
    )
  }

  /** Gets the API node for a non-root state access into which `pred` flows from a reducer function. */
  private API::Node getAStateAccessSuccessor(DataFlow::Node pred) {
    exists(ReducerArg reducer, DataFlow::FunctionNode function |
      function = reducer.getASource()
    |
      pred = function.getReturnNode() and
      result = getAnAffectedStateAccess(reducer)
      or
      reducer.isRootStateHandler() and
      exists(string prop |
        pred = function.getReturnNode().getALocalSource().getAPropertyWrite(prop).getRhs() and
        result = rootStatePropFrom(prop, reducer.getTopLevel())
      )
    )
  }

  /**
   * Holds if `pred -> succ` is a step from the return value of a reducer function to
   * a corresponding state access.
   */
  predicate reducerToStateStep(DataFlow::Node pred, DataFlow::SourceNode succ) {
    succ = getAStateAccessSuccessor(pred).getAnImmediateUse()
  }

  private class ReducerToStateStep extends DataFlow::AdditionalFlowStep {
    ReducerToStateStep() {
      reducerToStateStep(_, this)
    }

    override predicate step(DataFlow::Node pred, DataFlow::Node succ) {
      reducerToStateStep(pred, succ) and succ = this
    }
  }

  /**
   * Gets a dispatched object literal with a property `type: actionType`.
   */
  private DataFlow::ObjectLiteralNode getAManuallyDispatchedValue(string actionType) {
    result.getAPropertyWrite("type").getRhs().mayHaveStringValue(actionType) and
    result = getADispatchedValueSource()
  }

  /**
   * Gets the block to be executed after a check has determined that `action.type` is `actionType`.
   */
  private ReachableBasicBlock getASuccessfulTypeCheckBlock(DataFlow::SourceNode action, string actionType) {
    action = getAnUntypedActionInReducer() and
    (
      exists(MembershipCandidate candidate, ConditionGuardNode guard |
        action.getAPropertyRead("type").flowsTo(candidate) and
        candidate.getAMemberString() = actionType and
        guard.getTest() = candidate.getTest().asExpr() and
        guard.getOutcome() = candidate.getTestPolarity() and
        result = guard.getBasicBlock()
      )
      or
      exists(SwitchStmt switch, SwitchCase case |
        action.getAPropertyRead("type").flowsTo(switch.getExpr().flow()) and
        case = switch.getACase() and
        case.getExpr().mayHaveStringValue(actionType) and
        result = getCaseBlock(case)
      )
    )
  }

  /** Gets the block to execute with `case` matches sucessfully. */
  private BasicBlock getCaseBlock(SwitchCase case) {
    result = case.getBodyStmt(0).getBasicBlock()
    or
    not exists(case.getABodyStmt()) and
    exists(SwitchStmt stmt, int i |
      stmt.getCase(i) = case and
      result = getCaseBlock(stmt.getCase(i + 1))
    )
  }

  private module ReactRedux {
    API::Node useSelector() { result = API::moduleImport("react-redux").getMember("useSelector") }

    /**
     * Step out of a `useSelector` call, such as from `state.x` to the result of `useSelector(state => state.x)`.
     */
    class UseSelectorStep extends API::CallNode, DataFlow::AdditionalFlowStep {
      UseSelectorStep() { this = useSelector().getACall() }

      override predicate step(DataFlow::Node pred, DataFlow::Node succ) {
        pred = getParameter(0).getReturn().getARhs() and
        succ = this
      }
    }

    /** The argument to a `useSelector` callback, seen as a root state reference. */
    class UseSelectorStateSource extends RootStateNode {
      UseSelectorStateSource() { this = useSelector().getParameter(0).getParameter(0) }
    }

    /** A call to `useDispatch`, as a source of the `dispatch` function. */
    private class UseDispatchFunctionSource extends DispatchFunctionSource {
      UseDispatchFunctionSource() {
        this = API::moduleImport("react-redux").getMember("useDispatch").getReturn().getAnImmediateUse()
      }
    }

    /** A call to `connect`. */
    private class RealConnectFunction extends ConnectCall {
      RealConnectFunction() {
        this = API::moduleImport("react-redux").getMember("connect").getACall()
      }

      override API::Node getMapStateToProps() { result = getParameter(0) }

      override API::Node getMapDispatchToProps() { result = getParameter(1) }
    }

    private DataFlow::CallNode heuristicConnectCall() {
      result.getAnArgument().asExpr().(Identifier).getName() =
        ["mapStateToProps", "mapDispatchToProps"] and
      not result = DataFlow::moduleMember("react-redux", "connect").getACall() // exclude genuine calls to avoid duplicate tuples
    }

    /**
     * An entry point in the API graphs corresponding to functions named `mapDispatchToProps`,
     * used to catch cases where the call to `connect` was not found (usually because of it being
     * wrapped in another function, which API graphs won't look through).
     */
    private class HeuristicConnectEntryPoint extends API::EntryPoint {
      HeuristicConnectEntryPoint() { this = "react-redux-connect" }

      override DataFlow::Node getARhs() { none() }

      override DataFlow::SourceNode getAUse() {
        result = heuristicConnectCall().getCalleeNode().getALocalSource()
      }
    }

    /** A heuristic call to `connect`, recognized by it taking arguments named `mapStateToProps` and `mapDispatchToProps`. */
    private class HeuristicConnectFunction extends ConnectCall {
      HeuristicConnectFunction() {
        this = API::root().getASuccessor(any(HeuristicConnectEntryPoint e)).getACall()
      }

      override API::Node getMapStateToProps() {
        result = getAParameter() and
        result.getARhs().asExpr().(Identifier).getName() = "mapStateToProps"
      }

      override API::Node getMapDispatchToProps() {
        result = getAParameter() and
        result.getARhs().asExpr().(Identifier).getName() = "mapDispatchToProps"
      }
    }

    /**
     * A call to `connect()`, typically as part of a code pattern like the following:
     * ```js
     * let withConnect = connect(mapStateToProps, mapDispatchToProps);
     * let MyAwesomeComponent = compose(withConnect, otherStuff)(MyComponent);
     * ```
     */
    abstract private class ConnectCall extends API::CallNode {
      /** Gets the API node corresponding to the `mapStateToProps` argument. */
      abstract API::Node getMapStateToProps();

      /** Gets the API node corresponding to the `mapDispatchToProps` argument. */
      abstract API::Node getMapDispatchToProps();

      /**
       * Gets a function whose first argument becomes the React component to connect.
       */
      DataFlow::SourceNode getAComponentTransformer() {
        result = this
        or
        exists(FunctionCompositionCall compose |
          getAComponentTransformer().flowsTo(compose.getAnOperandNode()) and
          result = compose
        )
      }

      /**
       * Gets a data-flow node that should flow to `props.name` via the `mapDispatchToProps` function.
       */
      DataFlow::Node getDispatchPropNode(string name) {
        // Implicitly bound by bindActionCreators:
        //
        //   const mapDispatchToProps = { foo }
        //
        result = getMapDispatchToProps().getMember(name).getARhs()
        or
        // Explicitly bound by bindActionCreators:
        //
        //   const mapDispatchToProps = dispatch => bindActionCreators({ foo }, dispatch);
        //
        exists(BindActionCreatorsCall bind |
          bind.flowsTo(getMapDispatchToProps().getReturn().getARhs()) and
          result = bind.getOptionArgument(0, name)
        )
      }

      /**
       * Gets the React component decorated by this call, if one can be determined.
       */
      ReactComponent getReactComponent() {
        result
            .getAComponentCreatorReference()
            .flowsTo(getAComponentTransformer().getACall().getArgument(0))
      }
    }

    /**
     * Holds if `pred -> succ` is a step from the return value of `mapStateToProps` to
     * a `props` access.
     */
    predicate stateToPropsStep(DataFlow::Node pred, DataFlow::Node succ) {
      exists(ConnectCall call |
        pred = call.getMapStateToProps().getReturn().getARhs() and
        succ = call.getReactComponent().getADirectPropsAccess()
      )
    }

    /**
     * Holds if `pred -> succ` is a step from `mapDispatchToProps` to a `props` property access.
     */
    predicate dispatchToPropsStep(DataFlow::Node pred, DataFlow::Node succ) {
      exists(ConnectCall call, string member |
        pred = call.getDispatchPropNode(member) and
        succ = call.getReactComponent().getAPropRead(member)
      )
    }

    private class ConnectionStep extends DataFlow::AdditionalFlowStep {
      ConnectionStep() { stateToPropsStep(_, this) }

      override predicate step(DataFlow::Node pred, DataFlow::Node succ) {
        stateToPropsStep(pred, succ) and succ = this
      }
    }

    private class MapDispatchToPropsArg extends DispatchFunctionSource {
      MapDispatchToPropsArg() {
        // If `mapDispatchToProps` is a function, its first argument is `dispatch`
        this = any(ConnectCall c).getMapDispatchToProps().getParameter(0).getAnImmediateUse()
      }
    }

    private class MapDispatchToPropsMember extends DispatchedValueSink {
      MapDispatchToPropsMember() {
        // If `mapDispatchToProps` is an object, each method will have its result dispatched
        this = any(ConnectCall c).getMapDispatchToProps().getAMember().getReturn().getARhs()
      }
    }

    private class MapStateToPropsStateSource extends RootStateNode {
      MapStateToPropsStateSource() {
        // The first argument of `mapStateToProps` refers to the state
        this = any(ConnectCall c).getMapStateToProps().getParameter(0)
      }
    }
  }

  private module Reselect {
    class CreateSelectorCall extends API::CallNode {
      CreateSelectorCall() {
        this = API::moduleImport(["reselect", "@reduxjs/toolkit"]).getMember("createSelector").getACall()
      }

      /** Gets the `i`th selector callback, that is, a callback other than the result function. */
      API::Node getSelectorFunction(int i) {
        // When there are multiple callbacks, exclude the last one
        result = getParameter(i) and
        (i = 0 or i < getNumArgument() - 1)
        or
        // Selector functions may be given as an array
        exists(DataFlow::ArrayCreationNode array |
          array.flowsTo(getArgument(0)) and
          result.getAUse() = array.getElement(i)
        )
      }
    }

    /** The state argument to a selector */
    private class SelectorStateArg extends RootStateNode {
      SelectorStateArg() { this = any(CreateSelectorCall c).getSelectorFunction(_).getParameter(0) }
    }

    predicate selectorStep(DataFlow::Node pred, DataFlow::Node succ) {
      // Return value of `i`th callback flows to the `i`th parameter of the last callback.
      exists(CreateSelectorCall call, int index |
        call.getNumArgument() > 1 and
        pred = call.getSelectorFunction(index).getReturn().getARhs() and
        succ = call.getLastParameter().getParameter(index).getAnImmediateUse()
      )
      or
      // The result of the last callback is the final result
      exists(CreateSelectorCall call |
        pred = call.getLastParameter().getReturn().getARhs() and
        succ = call
      )
    }

    class SelectorStep extends DataFlow::AdditionalFlowStep {
      SelectorStep() { selectorStep(_, this) }

      override predicate step(DataFlow::Node pred, DataFlow::Node succ) {
        selectorStep(pred, succ) and
        this = succ
      }
    }
  }

  module Debbugging {
    predicate missedDispatch(DataFlow::SourceNode node) {
      // Many originally missed in grafana due to thunks in mapDispatchToProps functions, but found now
      // Still missing navigateToExplore due to: possibly unresolved import?
      node.asExpr().(Identifier).getName() = "dispatch" and
      not node = getADispatchFunctionReference()
    }

    predicate missedReducerUse(DataFlow::SourceNode node) {
      node.flowsToExpr(any(Identifier id | id.getName().regexpMatch("(?i).*reducer"))) and
      not node = any(ReducerArg arg).getASource()
    }

    predicate missedReducerFunction(DataFlow::FunctionNode function) {
      function.getParameter(0).getName() = "state" and
      (
        function.getParameter(1).getName() = "action"
        or
        exists(function.getParameter(1).getAPropertyRead("payload"))
      ) and
      not function = any(ReducerArg arg).getASource()
    }

    predicate missedPayloadSource(DataFlow::PropRead payload) {
      payload.getPropertyName() = "payload" and
      not payload = any(ActionCreator c).getAPayloadReference()
    }

    predicate unconnectedReducer(DelegatingReducer r) {
      // Findings:
      //   'workspaceReducer' in graphql-playground: manually invoked with state.getIn(['workspace', blah])
      //   combineReducers in Signal-Destop, not sure why
      not exists(r.getUseSite())
    }

    predicate test(DataFlow::PropWrite write, string name) {
      name = write.getPropertyNameExpr().getStringValue()
    }

    private Identifier withoutRelevantStore() {
      not exists(getAStoreRelevantFor(result.getTopLevel())) and
      not result.getTopLevel().isExterns() and
      result.getName() = ["state", "action", "mapStateToProps", "mapDispatchToProps"]
    }
  }
}
